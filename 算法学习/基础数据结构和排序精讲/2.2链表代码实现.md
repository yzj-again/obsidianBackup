---
tags:
  - ç®—æ³•
  - é“¾è¡¨
date: 2024-12-31
---
## å‡ ä¸ªå…³é”®ç‚¹

ä¸‹é¢æˆ‘ä¼šåˆ†åˆ«ç”¨åŒé“¾è¡¨å’Œå•é“¾ç»™å‡ºä¸€ä¸ªç®€å•çš„Â `MyLinkedList`Â ä»£ç å®ç°ï¼ŒåŒ…å«äº†åŸºæœ¬çš„å¢åˆ æŸ¥æ”¹åŠŸèƒ½ã€‚è¿™é‡Œç»™å‡ºå‡ ä¸ªå…³é”®ç‚¹ï¼Œç­‰ä¼šä½ çœ‹ä»£ç çš„æ—¶å€™å¯ä»¥ç€é‡æ³¨æ„ä¸€ä¸‹ã€‚

### å…³é”®ç‚¹ä¸€ã€åŒæ—¶æŒæœ‰å¤´å°¾èŠ‚ç‚¹çš„å¼•ç”¨

åœ¨åŠ›æ‰£åšé¢˜æ—¶ï¼Œä¸€èˆ¬é¢˜ç›®ç»™æˆ‘ä»¬ä¼ å…¥çš„å°±æ˜¯å•é“¾è¡¨çš„å¤´æŒ‡é’ˆã€‚ä½†æ˜¯åœ¨==å®é™…å¼€å‘ä¸­ï¼Œç”¨çš„éƒ½æ˜¯åŒé“¾è¡¨==ï¼Œè€ŒåŒé“¾è¡¨ä¸€èˆ¬ä¼š==åŒæ—¶æŒæœ‰å¤´å°¾èŠ‚ç‚¹çš„å¼•ç”¨==ã€‚

å› ä¸ºåœ¨è½¯ä»¶å¼€å‘ä¸­ï¼Œåœ¨å®¹å™¨å°¾éƒ¨æ·»åŠ å…ƒç´ æ˜¯ä¸ªéå¸¸é«˜é¢‘çš„æ“ä½œï¼ŒåŒé“¾è¡¨æŒæœ‰å°¾éƒ¨èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œå°±å¯ä»¥åœ¨Â Â çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆå°¾éƒ¨æ·»åŠ å…ƒç´ çš„æ“ä½œã€‚

å¯¹äºå•é“¾è¡¨æ¥è¯´ï¼ŒæŒæœ‰å°¾éƒ¨èŠ‚ç‚¹çš„å¼•ç”¨ä¹Ÿæœ‰ä¼˜åŒ–æ•ˆæœã€‚æ¯”å¦‚ä½ è¦åœ¨å•é“¾è¡¨å°¾éƒ¨æ·»åŠ å…ƒç´ ï¼Œå¦‚æœæ²¡æœ‰å°¾éƒ¨èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œä½ å°±éœ€è¦éå†æ•´ä¸ªé“¾è¡¨æ‰¾åˆ°å°¾éƒ¨èŠ‚ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯Â $O(N)$ï¼›å¦‚æœæœ‰å°¾éƒ¨èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œå°±å¯ä»¥åœ¨Â $O(1)$ çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆå°¾éƒ¨æ·»åŠ å…ƒç´ çš„æ“ä½œã€‚

ç»†å¿ƒçš„è¯»è€…å¯èƒ½ä¼šè¯´ï¼Œå³ä¾¿å¦‚æ­¤ï¼Œå¦‚æœåˆ é™¤ä¸€æ¬¡å•é“¾è¡¨çš„å°¾ç»“ç‚¹ï¼Œé‚£ä¹ˆä¹‹å‰å°¾ç»“ç‚¹çš„å¼•ç”¨å°±å¤±æ•ˆäº†ï¼Œè¿˜æ˜¯éœ€è¦éå†ä¸€éé“¾è¡¨æ‰¾åˆ°å°¾ç»“ç‚¹ã€‚

æ˜¯çš„ï¼Œä½†ä½ å†ä»”ç»†æƒ³æƒ³ï¼Œåˆ é™¤å•é“¾è¡¨å°¾ç»“ç‚¹çš„æ—¶å€™ï¼Œæ˜¯ä¸æ˜¯ä¹Ÿå¾—éå†åˆ°å€’æ•°ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼ˆå°¾ç»“ç‚¹çš„å‰é©±ï¼‰ï¼Œæ‰èƒ½é€šè¿‡æŒ‡é’ˆæ“ä½œæŠŠå°¾ç»“ç‚¹åˆ æ‰ï¼Ÿé‚£ä¹ˆè¿™ä¸ªæ—¶å€™ï¼Œä½ ä¸å°±å¯ä»¥é¡ºä¾¿æŠŠå°¾ç»“ç‚¹çš„å¼•ç”¨ç»™æ›´æ–°äº†å—ï¼Ÿ

### å…³é”®ç‚¹äºŒã€è™šæ‹Ÿå¤´å°¾èŠ‚ç‚¹

åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ==é“¾è¡¨åŸºç¡€==ä¸­æˆ‘æåˆ°è¿‡ã€Œè™šæ‹Ÿå¤´å°¾èŠ‚ç‚¹ã€æŠ€å·§ï¼Œå®ƒçš„åŸç†å¾ˆç®€å•ï¼Œå°±æ˜¯åœ¨åˆ›å»ºåŒé“¾è¡¨æ—¶å°±åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹å’Œä¸€ä¸ªè™šæ‹Ÿå°¾èŠ‚ç‚¹ï¼Œæ— è®ºåŒé“¾è¡¨æ˜¯å¦ä¸ºç©ºï¼Œè¿™ä¸¤ä¸ªèŠ‚ç‚¹éƒ½å­˜åœ¨ã€‚è¿™æ ·å°±ä¸ä¼šå‡ºç°ç©ºæŒ‡é’ˆçš„é—®é¢˜ï¼Œå¯ä»¥==é¿å…å¾ˆå¤šè¾¹ç•Œæƒ…å†µçš„å¤„ç†==ã€‚

ä¸¾ä¾‹æ¥è¯´ï¼Œå‡è®¾è™šæ‹Ÿå¤´å°¾èŠ‚ç‚¹åˆ†åˆ«æ˜¯Â `dummyHead`Â å’ŒÂ `dummyTail`ï¼Œé‚£ä¹ˆä¸€æ¡ç©ºçš„åŒé“¾è¡¨é•¿è¿™æ ·ï¼š

```plain
dummyHead <-> dummyTail
```

å¦‚æœä½ æ·»åŠ Â `1,2,3`Â å‡ ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆé“¾è¡¨é•¿è¿™æ ·ï¼š

```plain
dummyHead <-> 1 <-> 2 <-> 3 <-> dummyTail
```

ä½ ä»¥å‰è¦æŠŠåœ¨å¤´éƒ¨æ’å…¥å…ƒç´ ã€åœ¨å°¾éƒ¨æ’å…¥å…ƒç´ å’Œåœ¨ä¸­é—´æ’å…¥å…ƒç´ å‡ ç§æƒ…å†µåˆ†å¼€è®¨è®ºï¼Œç°åœ¨æœ‰äº†å¤´å°¾è™šæ‹ŸèŠ‚ç‚¹ï¼Œæ— è®ºé“¾è¡¨æ˜¯å¦ä¸ºç©ºï¼Œéƒ½åªéœ€è¦è€ƒè™‘åœ¨ä¸­é—´æ’å…¥å…ƒç´ çš„æƒ…å†µå°±å¯ä»¥äº†ï¼Œè¿™æ ·ä»£ç ä¼šç®€æ´å¾ˆå¤šã€‚

å½“ç„¶ï¼Œè™šæ‹Ÿå¤´ç»“ç‚¹ä¼šå¤šå ç”¨ä¸€ç‚¹å†…å­˜ç©ºé—´ï¼Œä½†æ˜¯æ¯”èµ·ç»™ä½ è§£å†³çš„éº»çƒ¦ï¼Œè¿™ç‚¹ç©ºé—´æ¶ˆè€—æ˜¯åˆ’ç®—çš„ã€‚

å¯¹äºå•é“¾è¡¨ï¼Œ**è™šæ‹Ÿå¤´ç»“ç‚¹æœ‰ä¸€å®šçš„ç®€åŒ–ä½œç”¨ï¼Œä½†è™šæ‹Ÿå°¾èŠ‚ç‚¹æ²¡æœ‰å¤ªå¤§ä½œç”¨**ã€‚

è™šæ‹ŸèŠ‚ç‚¹æ˜¯å†…éƒ¨å®ç°ï¼Œå¯¹å¤–ä¸å¯è§

è™šæ‹ŸèŠ‚ç‚¹æ˜¯ä½ å†…éƒ¨å®ç°æ•°æ®ç»“æ„çš„æŠ€å·§ï¼Œå¯¹å¤–æ˜¯ä¸å¯è§çš„ã€‚æ¯”å¦‚æŒ‰ç…§ç´¢å¼•è·å–å…ƒç´ çš„Â `get(index)`Â æ–¹æ³•ï¼Œéƒ½æ˜¯ä»çœŸå®èŠ‚ç‚¹å¼€å§‹è®¡ç®—ç´¢å¼•ï¼Œè€Œä¸æ˜¯ä»è™šæ‹ŸèŠ‚ç‚¹å¼€å§‹è®¡ç®—ã€‚

### å…³é”®ç‚¹ä¸‰ã€å†…å­˜æ³„éœ²ï¼Ÿ

åœ¨å‰æ–‡==åŠ¨æ€æ•°ç»„å®ç°==ä¸­ï¼Œæˆ‘æåˆ°äº†åˆ é™¤å…ƒç´ æ—¶ï¼Œè¦æ³¨æ„å†…å­˜æ³„éœ²çš„é—®é¢˜ã€‚é‚£ä¹ˆåœ¨é“¾è¡¨ä¸­ï¼Œåˆ é™¤å…ƒç´ ä¼šä¸ä¼šä¹Ÿæœ‰å†…å­˜æ³„éœ²çš„é—®é¢˜å‘¢ï¼Ÿ

å°¤å…¶æ˜¯è¿™æ ·çš„å†™æ³•ï¼Œä½ è§‰å¾—æœ‰æ²¡æœ‰é—®é¢˜ï¼š

```plain
// å‡è®¾å•é“¾è¡¨å¤´ç»“ç‚¹ head = 1 -> 2 -> 3 -> 4 -> 5

// åˆ é™¤å•é“¾è¡¨å¤´ç»“ç‚¹
head = head.next;

// æ­¤æ—¶ head = 2 -> 3 -> 4 -> 5
```

ç»†å¿ƒçš„è¯»è€…å¯èƒ½è®¤ä¸ºè¿™æ ·å†™ä¼šæœ‰å†…å­˜æ³„éœ²çš„é—®é¢˜ï¼Œå› ä¸ºåŸæ¥çš„é‚£ä¸ªå¤´ç»“ç‚¹Â `1`Â çš„Â `next`Â æŒ‡é’ˆæ²¡æœ‰æ–­å¼€ï¼Œä¾ç„¶æŒ‡å‘ç€èŠ‚ç‚¹Â `2`ã€‚

ä½†å®é™…ä¸Šè¿™æ ·å†™æ˜¯ OK çš„ï¼Œå› ä¸º Java çš„åƒåœ¾å›æ”¶çš„åˆ¤æ–­æœºåˆ¶æ˜¯çœ‹è¿™ä¸ªå¯¹è±¡æ˜¯å¦è¢«åˆ«äººå¼•ç”¨ï¼Œè€Œå¹¶ä¸ä¼š care è¿™ä¸ªå¯¹è±¡æ˜¯å¦è¿˜å¼•ç”¨ç€åˆ«äººã€‚

é‚£ä¸ªèŠ‚ç‚¹Â `1`Â çš„Â `next`Â æŒ‡é’ˆç¡®å®è¿˜æŒ‡å‘ç€èŠ‚ç‚¹Â `2`ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰åˆ«çš„æŒ‡é’ˆå¼•ç”¨èŠ‚ç‚¹Â `1`Â äº†ï¼Œæ‰€ä»¥èŠ‚ç‚¹Â `1`Â æœ€ç»ˆä¼šè¢«åƒåœ¾å›æ”¶å™¨å›æ”¶é‡Šæ”¾ã€‚æ‰€ä»¥è¯´è¿™ä¸ªåœºæ™¯å’Œæ•°ç»„ä¸­åˆ é™¤å…ƒç´ çš„åœºæ™¯æ˜¯ä¸ä¸€æ ·çš„ï¼Œä½ å¯ä»¥å†ä»”ç»†æ€è€ƒä¸€ä¸‹ã€‚

ä¸è¿‡å‘¢ï¼Œåˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œæœ€å¥½è¿˜æ˜¯æŠŠè¢«åˆ é™¤èŠ‚ç‚¹çš„æŒ‡é’ˆéƒ½ç½®ä¸º nullï¼Œè¿™æ˜¯ä¸ªå¥½ä¹ æƒ¯ï¼Œä¸ä¼šæœ‰ä»€ä¹ˆä»£ä»·ï¼Œè¿˜å¯èƒ½é¿å…ä¸€äº›æ½œåœ¨çš„é—®é¢˜ã€‚æ‰€ä»¥åœ¨ä¸‹é¢çš„å®ç°ä¸­ï¼Œæ— è®ºæ˜¯å¦æœ‰å¿…è¦ï¼Œæˆ‘éƒ½ä¼šæŠŠè¢«åˆ é™¤èŠ‚ç‚¹ä¸Šçš„æŒ‡é’ˆç½®ä¸º nullã€‚

> ä»¥ä¸Šæ˜¯javaçš„æ€æƒ³ï¼Œå¦‚æœæ˜¯c++çš„è¯ï¼Œåˆ™å¿…é¡» `delete p`ã€‚

## åŒé“¾è¡¨ä»£ç å®ç°

```
#include <iostream>
#include <stdexcept>
// å®šä¹‰èŠ‚ç‚¹
template <typename T> struct ListNode;
template <typename T> using ListNodePosi = ListNode<T>*; //åˆ—è¡¨èŠ‚ç‚¹ä½ç½®

template<typename T>
class MyLinkedList {
    Node* head;
    Node* tail;
    int size;

public:
    // æ„é€ å‡½æ•°åˆå§‹åŒ–è™šæ‹Ÿå¤´å°¾èŠ‚ç‚¹
    MyLinkedList() {
        head = new Node(E());
        tail = new Node(E());
        head->next = tail;
        tail->prev = head;
        size = 0;
    }

    // ***** å¢ *****

    void addLast(E e) {
        Node* x = new Node(e);
        Node* temp = tail->prev;
        // temp <-> x
        temp->next = x;
        x->prev = temp;

        x->next = tail;
        tail->prev = x;
        // temp <-> x <-> tail
        size++;
    }

    void addFirst(E e) {
        Node* x = new Node(e);
        Node* temp = head->next;
        // head <-> temp
        temp->prev = x;
        x->next = temp;

        head->next = x;
        x->prev = head;
        // head <-> x <-> temp
        size++;
    }

    void add(int index, E element) {
        checkPositionIndex(index);
        if (index == size) {
            addLast(element);
            return;
        }

        // æ‰¾åˆ° index å¯¹åº”çš„ Node
        Node* p = getNode(index);
        Node* temp = p->prev;
        // temp <-> p

        // æ–°è¦æ’å…¥çš„ Node
        Node* x = new Node(element);

        p->prev = x;
        temp->next = x;

        x->prev = temp;
        x->next = p;

        // temp <-> x <-> p

        size++;
    }

    // ***** åˆ  *****

    E removeFirst() {
        if (size < 1) {
            throw std::out_of_range("No elements to remove");
        }
        // è™šæ‹ŸèŠ‚ç‚¹çš„å­˜åœ¨æ˜¯æˆ‘ä»¬ä¸ç”¨è€ƒè™‘ç©ºæŒ‡é’ˆçš„é—®é¢˜
        Node* x = head->next;
        Node* temp = x->next;
        // head <-> x <-> temp
        head->next = temp;
        temp->prev = head;

        delete x;
        // head <-> temp

        size--;
        return temp->val;
    }

    E removeLast() {
        if (size < 1) {
            throw std::out_of_range("No elements to remove");
        }
        Node* x = tail->prev;
        Node* temp = tail->prev->prev;
        // temp <-> x <-> tail

        tail->prev = temp;
        temp->next = tail;

        delete x;
        // temp <-> tail

        size--;
        return temp->val;
    }

    E remove(int index) {
        checkElementIndex(index);
        // æ‰¾åˆ° index å¯¹åº”çš„ Node
        Node* x = getNode(index);
        Node* prev = x->prev;
        Node* next = x->next;
        // prev <-> x <-> next
        prev->next = next;
        next->prev = prev;

        delete x;
        // prev <-> next

        size--;

        return next->val;
    }

    // ***** æŸ¥ *****

    E get(int index) {
        checkElementIndex(index);
        // æ‰¾åˆ° index å¯¹åº”çš„ Node
        Node* p = getNode(index);

        return p->val;
    }

    E getFirst() {
        if (size < 1) {
            throw std::out_of_range("No elements in the list");
        }

        return head->next->val;
    }

    E getLast() {
        if (size < 1) {
            throw std::out_of_range("No elements in the list");
        }

        return tail->prev->val;
    }

    // ***** æ”¹ *****

    E set(int index, E val) {
        checkElementIndex(index);
        // æ‰¾åˆ° index å¯¹åº”çš„ Node
        Node* p = getNode(index);

        E oldVal = p->val;
        p->val = val;

        return oldVal;
    }

    // ***** å…¶ä»–å·¥å…·å‡½æ•° *****

    int getSize() const {
        return size;
    }

    bool isEmpty() const {
        return size == 0;
    }

private:
    Node* getNode(int index) {
        checkElementIndex(index);
        Node* p = head->next;
        // TODO: å¯ä»¥ä¼˜åŒ–ï¼Œé€šè¿‡ index åˆ¤æ–­ä» head è¿˜æ˜¯ tail å¼€å§‹éå†
        for (int i = 0; i < index; i++) {
            p = p->next;
        }
        return p;
    }

    bool isElementIndex(int index) const {
        return index >= 0 && index < size;
    }

    bool isPositionIndex(int index) const {
        return index >= 0 && index <= size;
    }

    // æ£€æŸ¥ index ç´¢å¼•ä½ç½®æ˜¯å¦å¯ä»¥å­˜åœ¨å…ƒç´ 
    void checkElementIndex(int index) const {
        if (!isElementIndex(index))
            throw std::out_of_range("Index: " + std::to_string(index) + ", Size: " + std::to_string(size));
    }

    // æ£€æŸ¥ index ç´¢å¼•ä½ç½®æ˜¯å¦å¯ä»¥æ·»åŠ å…ƒç´ 
    void checkPositionIndex(int index) const {
        if (!isPositionIndex(index))
            throw std::out_of_range("Index: " + std::to_string(index) + ", Size: " + std::to_string(size));
    }

public:
    void display() {
        std::cout << "size = " << size << std::endl;
        for (Node* p = head->next; p != tail; p = p->next) {
            std::cout << p->val << " <-> ";
        }
        std::cout << "null" << std::endl;
        std::cout << std::endl;
    }

    ~MyLinkedList() {
        while (size > 0) {
            removeFirst();
        }
        delete head;
        delete tail;
    }
};

int main() {
    MyLinkedList<int> list;
    list.addLast(1);
    list.addLast(2);
    list.addLast(3);
    list.addFirst(0);
    list.add(2, 100);

    list.display();
    // size = 5
    // 0 <-> 1 <-> 100 <-> 2 <-> 3 <-> null

    return 0;
}
```

## [å•é“¾è¡¨ä»£ç å®ç°](https://labuladong.online/algo/data-structure-basic/linkedlist-implement/#%E5%8D%95%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)

java ğŸŸ¢cpp ğŸ¤–python ğŸ¤–javascript ğŸ¤–golang ğŸ¤–

```
#include <iostream>
#include <stdexcept>

template <typename E>
class MyLinkedList2 {
private:
    // èŠ‚ç‚¹ç»“æ„
    struct Node {
        E val;
        Node* next;

        Node(E value) : val(value), next(nullptr) {}
    };

    Node* head;
    // å®é™…çš„å°¾éƒ¨èŠ‚ç‚¹å¼•ç”¨
    Node* tail;
    int size_;

public:
    MyLinkedList2() {
        head = new Node(E());
        tail = head;
        size_ = 0;
    }

    void addFirst(E e) {
        Node* newNode = new Node(e);
        newNode->next = head->next;
        head->next = newNode;
        if (size_ == 0) {
            tail = newNode;
        }
        size_++;
    }

    void addLast(E e) {
        Node* newNode = new Node(e);
        tail->next = newNode;
        tail = newNode;
        size_++;
    }

    void add(int index, E element) {
        checkPositionIndex(index);

        if (index == size_) {
            addLast(element);
            return;
        }

        Node* prev = head;
        for (int i = 0; i < index; i++) {
            prev = prev->next;
        }
        Node* newNode = new Node(element);
        newNode->next = prev->next;
        prev->next = newNode;
        size_++;
    }

    E removeFirst() {
        if (isEmpty()) {
            throw std::out_of_range("No elements to remove");
        }
        Node* first = head->next;
        head->next = first->next;
        if (size_ == 1) {
            tail = head;
        }
        size_--;
        E val = first->val;
        delete first;
        return val;
    }

    E removeLast() {
        if (isEmpty()) {
            throw std::out_of_range("No elements to remove");
        }

        Node* prev = head;
        while (prev->next != tail) {
            prev = prev->next;
        }
        E val = tail->val;
        delete tail;
        prev->next = nullptr;
        tail = prev;
        size_--;
        return val;
    }

    E remove(int index) {
        checkElementIndex(index);

        Node* prev = head;
        for (int i = 0; i < index; i++) {
            prev = prev->next;
        }

        Node* nodeToRemove = prev->next;
        prev->next = nodeToRemove->next;
        // åˆ é™¤çš„æ˜¯æœ€åä¸€ä¸ªå…ƒç´ 
        if (index == size_ - 1) {
            tail = prev;
        }
        size_--;
        E val = nodeToRemove->val;
        delete nodeToRemove;
        return val;
    }

    // ***** æŸ¥ *****

    E getFirst() {
        if (isEmpty()) {
            throw std::out_of_range("No elements in the list");
        }
        return head->next->val;
    }

    E getLast() {
        if (isEmpty()) {
            throw std::out_of_range("No elements in the list");
        }
        return getNode(size_ - 1)->val;
    }

    E get(int index) {
        checkElementIndex(index);
        Node* p = getNode(index);
        return p->val;
    }

    // ***** æ”¹ *****

    E set(int index, E element) {
        checkElementIndex(index);
        Node* p = getNode(index);

        E oldVal = p->val;
        p->val = element;

        return oldVal;
    }

    // ***** å…¶ä»–å·¥å…·å‡½æ•° *****
    int size() {
        return size_;
    }

    bool isEmpty() {
        return size_ == 0;
    }

private:
    bool isElementIndex(int index) {
        return index >= 0 && index < size_;
    }

    bool isPositionIndex(int index) {
        return index >= 0 && index <= size_;
    }

    // æ£€æŸ¥ index ç´¢å¼•ä½ç½®æ˜¯å¦å¯ä»¥å­˜åœ¨å…ƒç´ 
    void checkElementIndex(int index) {
        if (!isElementIndex(index)) {
            throw std::out_of_range("Index: " + std::to_string(index) + ", size_: " + std::to_string(size_));
        }
    }

    // æ£€æŸ¥ index ç´¢å¼•ä½ç½®æ˜¯å¦å¯ä»¥æ·»åŠ å…ƒç´ 
    void checkPositionIndex(int index) {
        if (!isPositionIndex(index)) {
            throw std::out_of_range("Index: " + std::to_string(index) + ", size_: " + std::to_string(size_));
        }
    }

    // è¿”å› index å¯¹åº”çš„ Node
    // æ³¨æ„ï¼šè¯·ä¿è¯ä¼ å…¥çš„ index æ˜¯åˆæ³•çš„
    Node* getNode(int index) {
        Node* p = head->next;
        for (int i = 0; i < index; i++) {
            p = p->next;
        }
        return p;
    }
};

int main() {
    MyLinkedList2<int> list;
    list.addFirst(1);
    list.addFirst(2);
    list.addLast(3);
    list.addLast(4);
    list.add(2, 5);

    std::cout << list.removeFirst() << std::endl; // 2
    std::cout << list.removeLast() << std::endl; // 4
    std::cout << list.remove(1) << std::endl; // 5

    std::cout << list.getFirst() << std::endl; // 1
    std::cout << list.getLast() << std::endl; // 3
    std::cout << list.get(1) << std::endl; // 3

    return 0;
}
```